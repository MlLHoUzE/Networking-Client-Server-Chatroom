// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Headers.proto

#ifndef PROTOBUF_Headers_2eproto__INCLUDED
#define PROTOBUF_Headers_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3001000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3001000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace headers {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_Headers_2eproto();
void protobuf_InitDefaults_Headers_2eproto();
void protobuf_AssignDesc_Headers_2eproto();
void protobuf_ShutdownFile_Headers_2eproto();

class AuthenticateFailure;
class AuthenticateLogin;
class AuthenticateSuccess;
class Container;
class CreateAccount;
class CreateAccountFailure;
class CreateAccountSuccess;
class Message;

enum CreateAccountFailure_reason {
  CreateAccountFailure_reason_ACCOUNT_ALREADY_EXISTS = -12312,
  CreateAccountFailure_reason_INVALID_PASSWORD = -32132,
  CreateAccountFailure_reason_INTERNAL_SERVER_ERROR = -12721
};
bool CreateAccountFailure_reason_IsValid(int value);
const CreateAccountFailure_reason CreateAccountFailure_reason_reason_MIN = CreateAccountFailure_reason_INVALID_PASSWORD;
const CreateAccountFailure_reason CreateAccountFailure_reason_reason_MAX = CreateAccountFailure_reason_ACCOUNT_ALREADY_EXISTS;
const int CreateAccountFailure_reason_reason_ARRAYSIZE = CreateAccountFailure_reason_reason_MAX + 1;

const ::google::protobuf::EnumDescriptor* CreateAccountFailure_reason_descriptor();
inline const ::std::string& CreateAccountFailure_reason_Name(CreateAccountFailure_reason value) {
  return ::google::protobuf::internal::NameOfEnum(
    CreateAccountFailure_reason_descriptor(), value);
}
inline bool CreateAccountFailure_reason_Parse(
    const ::std::string& name, CreateAccountFailure_reason* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CreateAccountFailure_reason>(
    CreateAccountFailure_reason_descriptor(), name, value);
}
enum AuthenticateFailure_reason {
  AuthenticateFailure_reason_INVALID_CREDENTIALS = -14714,
  AuthenticateFailure_reason_INTERNAL_SERVER_ERROR = -12721
};
bool AuthenticateFailure_reason_IsValid(int value);
const AuthenticateFailure_reason AuthenticateFailure_reason_reason_MIN = AuthenticateFailure_reason_INVALID_CREDENTIALS;
const AuthenticateFailure_reason AuthenticateFailure_reason_reason_MAX = AuthenticateFailure_reason_INTERNAL_SERVER_ERROR;
const int AuthenticateFailure_reason_reason_ARRAYSIZE = AuthenticateFailure_reason_reason_MAX + 1;

const ::google::protobuf::EnumDescriptor* AuthenticateFailure_reason_descriptor();
inline const ::std::string& AuthenticateFailure_reason_Name(AuthenticateFailure_reason value) {
  return ::google::protobuf::internal::NameOfEnum(
    AuthenticateFailure_reason_descriptor(), value);
}
inline bool AuthenticateFailure_reason_Parse(
    const ::std::string& name, AuthenticateFailure_reason* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AuthenticateFailure_reason>(
    AuthenticateFailure_reason_descriptor(), name, value);
}
enum Container_requestID {
  Container_requestID_ID_CREATE = -22022,
  Container_requestID_ID_CREATE_SUCCESS = -12645,
  Container_requestID_ID_CREATE_FAIL = -16452,
  Container_requestID_ID_AUTHENTICATE_SUCCESS = -19875,
  Container_requestID_ID_AUTHENTICATE_FAILURE = -15789,
  Container_requestID_ID_LOGIN = -12121,
  Container_requestID_ID_JOIN = -22222,
  Container_requestID_ID_LEAVE = -22250,
  Container_requestID_ID_MESSAGE = -11111
};
bool Container_requestID_IsValid(int value);
const Container_requestID Container_requestID_requestID_MIN = Container_requestID_ID_LEAVE;
const Container_requestID Container_requestID_requestID_MAX = Container_requestID_ID_MESSAGE;
const int Container_requestID_requestID_ARRAYSIZE = Container_requestID_requestID_MAX + 1;

const ::google::protobuf::EnumDescriptor* Container_requestID_descriptor();
inline const ::std::string& Container_requestID_Name(Container_requestID value) {
  return ::google::protobuf::internal::NameOfEnum(
    Container_requestID_descriptor(), value);
}
inline bool Container_requestID_Parse(
    const ::std::string& name, Container_requestID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Container_requestID>(
    Container_requestID_descriptor(), name, value);
}
// ===================================================================

class CreateAccount : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:headers.CreateAccount) */ {
 public:
  CreateAccount();
  virtual ~CreateAccount();

  CreateAccount(const CreateAccount& from);

  inline CreateAccount& operator=(const CreateAccount& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateAccount& default_instance();

  static const CreateAccount* internal_default_instance();

  void Swap(CreateAccount* other);

  // implements Message ----------------------------------------------

  inline CreateAccount* New() const { return New(NULL); }

  CreateAccount* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateAccount& from);
  void MergeFrom(const CreateAccount& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CreateAccount* other);
  void UnsafeMergeFrom(const CreateAccount& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string userName = 1;
  bool has_username() const;
  void clear_username();
  static const int kUserNameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // required string password = 2;
  bool has_password() const;
  void clear_password();
  static const int kPasswordFieldNumber = 2;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:headers.CreateAccount)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  friend void  protobuf_InitDefaults_Headers_2eproto_impl();
  friend void  protobuf_AddDesc_Headers_2eproto_impl();
  friend void protobuf_AssignDesc_Headers_2eproto();
  friend void protobuf_ShutdownFile_Headers_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<CreateAccount> CreateAccount_default_instance_;

// -------------------------------------------------------------------

class CreateAccountSuccess : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:headers.CreateAccountSuccess) */ {
 public:
  CreateAccountSuccess();
  virtual ~CreateAccountSuccess();

  CreateAccountSuccess(const CreateAccountSuccess& from);

  inline CreateAccountSuccess& operator=(const CreateAccountSuccess& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateAccountSuccess& default_instance();

  static const CreateAccountSuccess* internal_default_instance();

  void Swap(CreateAccountSuccess* other);

  // implements Message ----------------------------------------------

  inline CreateAccountSuccess* New() const { return New(NULL); }

  CreateAccountSuccess* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateAccountSuccess& from);
  void MergeFrom(const CreateAccountSuccess& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CreateAccountSuccess* other);
  void UnsafeMergeFrom(const CreateAccountSuccess& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string userID = 1;
  bool has_userid() const;
  void clear_userid();
  static const int kUserIDFieldNumber = 1;
  const ::std::string& userid() const;
  void set_userid(const ::std::string& value);
  void set_userid(const char* value);
  void set_userid(const char* value, size_t size);
  ::std::string* mutable_userid();
  ::std::string* release_userid();
  void set_allocated_userid(::std::string* userid);

  // @@protoc_insertion_point(class_scope:headers.CreateAccountSuccess)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr userid_;
  friend void  protobuf_InitDefaults_Headers_2eproto_impl();
  friend void  protobuf_AddDesc_Headers_2eproto_impl();
  friend void protobuf_AssignDesc_Headers_2eproto();
  friend void protobuf_ShutdownFile_Headers_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<CreateAccountSuccess> CreateAccountSuccess_default_instance_;

// -------------------------------------------------------------------

class CreateAccountFailure : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:headers.CreateAccountFailure) */ {
 public:
  CreateAccountFailure();
  virtual ~CreateAccountFailure();

  CreateAccountFailure(const CreateAccountFailure& from);

  inline CreateAccountFailure& operator=(const CreateAccountFailure& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateAccountFailure& default_instance();

  static const CreateAccountFailure* internal_default_instance();

  void Swap(CreateAccountFailure* other);

  // implements Message ----------------------------------------------

  inline CreateAccountFailure* New() const { return New(NULL); }

  CreateAccountFailure* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateAccountFailure& from);
  void MergeFrom(const CreateAccountFailure& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CreateAccountFailure* other);
  void UnsafeMergeFrom(const CreateAccountFailure& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CreateAccountFailure_reason reason;
  static const reason ACCOUNT_ALREADY_EXISTS =
    CreateAccountFailure_reason_ACCOUNT_ALREADY_EXISTS;
  static const reason INVALID_PASSWORD =
    CreateAccountFailure_reason_INVALID_PASSWORD;
  static const reason INTERNAL_SERVER_ERROR =
    CreateAccountFailure_reason_INTERNAL_SERVER_ERROR;
  static inline bool reason_IsValid(int value) {
    return CreateAccountFailure_reason_IsValid(value);
  }
  static const reason reason_MIN =
    CreateAccountFailure_reason_reason_MIN;
  static const reason reason_MAX =
    CreateAccountFailure_reason_reason_MAX;
  static const int reason_ARRAYSIZE =
    CreateAccountFailure_reason_reason_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  reason_descriptor() {
    return CreateAccountFailure_reason_descriptor();
  }
  static inline const ::std::string& reason_Name(reason value) {
    return CreateAccountFailure_reason_Name(value);
  }
  static inline bool reason_Parse(const ::std::string& name,
      reason* value) {
    return CreateAccountFailure_reason_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .headers.CreateAccountFailure.reason errorReason = 1;
  bool has_errorreason() const;
  void clear_errorreason();
  static const int kErrorReasonFieldNumber = 1;
  ::headers::CreateAccountFailure_reason errorreason() const;
  void set_errorreason(::headers::CreateAccountFailure_reason value);

  // @@protoc_insertion_point(class_scope:headers.CreateAccountFailure)
 private:
  inline void set_has_errorreason();
  inline void clear_has_errorreason();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int errorreason_;
  friend void  protobuf_InitDefaults_Headers_2eproto_impl();
  friend void  protobuf_AddDesc_Headers_2eproto_impl();
  friend void protobuf_AssignDesc_Headers_2eproto();
  friend void protobuf_ShutdownFile_Headers_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<CreateAccountFailure> CreateAccountFailure_default_instance_;

// -------------------------------------------------------------------

class AuthenticateLogin : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:headers.AuthenticateLogin) */ {
 public:
  AuthenticateLogin();
  virtual ~AuthenticateLogin();

  AuthenticateLogin(const AuthenticateLogin& from);

  inline AuthenticateLogin& operator=(const AuthenticateLogin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthenticateLogin& default_instance();

  static const AuthenticateLogin* internal_default_instance();

  void Swap(AuthenticateLogin* other);

  // implements Message ----------------------------------------------

  inline AuthenticateLogin* New() const { return New(NULL); }

  AuthenticateLogin* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AuthenticateLogin& from);
  void MergeFrom(const AuthenticateLogin& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AuthenticateLogin* other);
  void UnsafeMergeFrom(const AuthenticateLogin& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string userName = 1;
  bool has_username() const;
  void clear_username();
  static const int kUserNameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // required string password = 2;
  bool has_password() const;
  void clear_password();
  static const int kPasswordFieldNumber = 2;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:headers.AuthenticateLogin)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  friend void  protobuf_InitDefaults_Headers_2eproto_impl();
  friend void  protobuf_AddDesc_Headers_2eproto_impl();
  friend void protobuf_AssignDesc_Headers_2eproto();
  friend void protobuf_ShutdownFile_Headers_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<AuthenticateLogin> AuthenticateLogin_default_instance_;

// -------------------------------------------------------------------

class AuthenticateSuccess : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:headers.AuthenticateSuccess) */ {
 public:
  AuthenticateSuccess();
  virtual ~AuthenticateSuccess();

  AuthenticateSuccess(const AuthenticateSuccess& from);

  inline AuthenticateSuccess& operator=(const AuthenticateSuccess& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthenticateSuccess& default_instance();

  static const AuthenticateSuccess* internal_default_instance();

  void Swap(AuthenticateSuccess* other);

  // implements Message ----------------------------------------------

  inline AuthenticateSuccess* New() const { return New(NULL); }

  AuthenticateSuccess* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AuthenticateSuccess& from);
  void MergeFrom(const AuthenticateSuccess& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AuthenticateSuccess* other);
  void UnsafeMergeFrom(const AuthenticateSuccess& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string userID = 1;
  bool has_userid() const;
  void clear_userid();
  static const int kUserIDFieldNumber = 1;
  const ::std::string& userid() const;
  void set_userid(const ::std::string& value);
  void set_userid(const char* value);
  void set_userid(const char* value, size_t size);
  ::std::string* mutable_userid();
  ::std::string* release_userid();
  void set_allocated_userid(::std::string* userid);

  // required string creationDate = 2;
  bool has_creationdate() const;
  void clear_creationdate();
  static const int kCreationDateFieldNumber = 2;
  const ::std::string& creationdate() const;
  void set_creationdate(const ::std::string& value);
  void set_creationdate(const char* value);
  void set_creationdate(const char* value, size_t size);
  ::std::string* mutable_creationdate();
  ::std::string* release_creationdate();
  void set_allocated_creationdate(::std::string* creationdate);

  // @@protoc_insertion_point(class_scope:headers.AuthenticateSuccess)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_creationdate();
  inline void clear_has_creationdate();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr userid_;
  ::google::protobuf::internal::ArenaStringPtr creationdate_;
  friend void  protobuf_InitDefaults_Headers_2eproto_impl();
  friend void  protobuf_AddDesc_Headers_2eproto_impl();
  friend void protobuf_AssignDesc_Headers_2eproto();
  friend void protobuf_ShutdownFile_Headers_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<AuthenticateSuccess> AuthenticateSuccess_default_instance_;

// -------------------------------------------------------------------

class AuthenticateFailure : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:headers.AuthenticateFailure) */ {
 public:
  AuthenticateFailure();
  virtual ~AuthenticateFailure();

  AuthenticateFailure(const AuthenticateFailure& from);

  inline AuthenticateFailure& operator=(const AuthenticateFailure& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthenticateFailure& default_instance();

  static const AuthenticateFailure* internal_default_instance();

  void Swap(AuthenticateFailure* other);

  // implements Message ----------------------------------------------

  inline AuthenticateFailure* New() const { return New(NULL); }

  AuthenticateFailure* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AuthenticateFailure& from);
  void MergeFrom(const AuthenticateFailure& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AuthenticateFailure* other);
  void UnsafeMergeFrom(const AuthenticateFailure& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef AuthenticateFailure_reason reason;
  static const reason INVALID_CREDENTIALS =
    AuthenticateFailure_reason_INVALID_CREDENTIALS;
  static const reason INTERNAL_SERVER_ERROR =
    AuthenticateFailure_reason_INTERNAL_SERVER_ERROR;
  static inline bool reason_IsValid(int value) {
    return AuthenticateFailure_reason_IsValid(value);
  }
  static const reason reason_MIN =
    AuthenticateFailure_reason_reason_MIN;
  static const reason reason_MAX =
    AuthenticateFailure_reason_reason_MAX;
  static const int reason_ARRAYSIZE =
    AuthenticateFailure_reason_reason_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  reason_descriptor() {
    return AuthenticateFailure_reason_descriptor();
  }
  static inline const ::std::string& reason_Name(reason value) {
    return AuthenticateFailure_reason_Name(value);
  }
  static inline bool reason_Parse(const ::std::string& name,
      reason* value) {
    return AuthenticateFailure_reason_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .headers.AuthenticateFailure.reason errorReason = 1;
  bool has_errorreason() const;
  void clear_errorreason();
  static const int kErrorReasonFieldNumber = 1;
  ::headers::AuthenticateFailure_reason errorreason() const;
  void set_errorreason(::headers::AuthenticateFailure_reason value);

  // @@protoc_insertion_point(class_scope:headers.AuthenticateFailure)
 private:
  inline void set_has_errorreason();
  inline void clear_has_errorreason();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int errorreason_;
  friend void  protobuf_InitDefaults_Headers_2eproto_impl();
  friend void  protobuf_AddDesc_Headers_2eproto_impl();
  friend void protobuf_AssignDesc_Headers_2eproto();
  friend void protobuf_ShutdownFile_Headers_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<AuthenticateFailure> AuthenticateFailure_default_instance_;

// -------------------------------------------------------------------

class Message : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:headers.Message) */ {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();

  static const Message* internal_default_instance();

  void Swap(Message* other);

  // implements Message ----------------------------------------------

  inline Message* New() const { return New(NULL); }

  Message* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Message* other);
  void UnsafeMergeFrom(const Message& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string userName = 1;
  bool has_username() const;
  void clear_username();
  static const int kUserNameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // required string roomName = 2;
  bool has_roomname() const;
  void clear_roomname();
  static const int kRoomNameFieldNumber = 2;
  const ::std::string& roomname() const;
  void set_roomname(const ::std::string& value);
  void set_roomname(const char* value);
  void set_roomname(const char* value, size_t size);
  ::std::string* mutable_roomname();
  ::std::string* release_roomname();
  void set_allocated_roomname(::std::string* roomname);

  // required string message = 3;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 3;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:headers.Message)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_roomname();
  inline void clear_has_roomname();
  inline void set_has_message();
  inline void clear_has_message();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr roomname_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  friend void  protobuf_InitDefaults_Headers_2eproto_impl();
  friend void  protobuf_AddDesc_Headers_2eproto_impl();
  friend void protobuf_AssignDesc_Headers_2eproto();
  friend void protobuf_ShutdownFile_Headers_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Message> Message_default_instance_;

// -------------------------------------------------------------------

class Container : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:headers.Container) */ {
 public:
  Container();
  virtual ~Container();

  Container(const Container& from);

  inline Container& operator=(const Container& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Container& default_instance();

  static const Container* internal_default_instance();

  void Swap(Container* other);

  // implements Message ----------------------------------------------

  inline Container* New() const { return New(NULL); }

  Container* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Container& from);
  void MergeFrom(const Container& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Container* other);
  void UnsafeMergeFrom(const Container& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Container_requestID requestID;
  static const requestID ID_CREATE =
    Container_requestID_ID_CREATE;
  static const requestID ID_CREATE_SUCCESS =
    Container_requestID_ID_CREATE_SUCCESS;
  static const requestID ID_CREATE_FAIL =
    Container_requestID_ID_CREATE_FAIL;
  static const requestID ID_AUTHENTICATE_SUCCESS =
    Container_requestID_ID_AUTHENTICATE_SUCCESS;
  static const requestID ID_AUTHENTICATE_FAILURE =
    Container_requestID_ID_AUTHENTICATE_FAILURE;
  static const requestID ID_LOGIN =
    Container_requestID_ID_LOGIN;
  static const requestID ID_JOIN =
    Container_requestID_ID_JOIN;
  static const requestID ID_LEAVE =
    Container_requestID_ID_LEAVE;
  static const requestID ID_MESSAGE =
    Container_requestID_ID_MESSAGE;
  static inline bool requestID_IsValid(int value) {
    return Container_requestID_IsValid(value);
  }
  static const requestID requestID_MIN =
    Container_requestID_requestID_MIN;
  static const requestID requestID_MAX =
    Container_requestID_requestID_MAX;
  static const int requestID_ARRAYSIZE =
    Container_requestID_requestID_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  requestID_descriptor() {
    return Container_requestID_descriptor();
  }
  static inline const ::std::string& requestID_Name(requestID value) {
    return Container_requestID_Name(value);
  }
  static inline bool requestID_Parse(const ::std::string& name,
      requestID* value) {
    return Container_requestID_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int32 packetLength = 1;
  bool has_packetlength() const;
  void clear_packetlength();
  static const int kPacketLengthFieldNumber = 1;
  ::google::protobuf::int32 packetlength() const;
  void set_packetlength(::google::protobuf::int32 value);

  // required .headers.Container.requestID ID = 2;
  bool has_id() const;
  void clear_id();
  static const int kIDFieldNumber = 2;
  ::headers::Container_requestID id() const;
  void set_id(::headers::Container_requestID value);

  // optional .headers.Message message = 3;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 3;
  const ::headers::Message& message() const;
  ::headers::Message* mutable_message();
  ::headers::Message* release_message();
  void set_allocated_message(::headers::Message* message);

  // optional .headers.CreateAccount create = 4;
  bool has_create() const;
  void clear_create();
  static const int kCreateFieldNumber = 4;
  const ::headers::CreateAccount& create() const;
  ::headers::CreateAccount* mutable_create();
  ::headers::CreateAccount* release_create();
  void set_allocated_create(::headers::CreateAccount* create);

  // optional .headers.CreateAccountFailure createFail = 5;
  bool has_createfail() const;
  void clear_createfail();
  static const int kCreateFailFieldNumber = 5;
  const ::headers::CreateAccountFailure& createfail() const;
  ::headers::CreateAccountFailure* mutable_createfail();
  ::headers::CreateAccountFailure* release_createfail();
  void set_allocated_createfail(::headers::CreateAccountFailure* createfail);

  // optional .headers.CreateAccountSuccess createSuccess = 6;
  bool has_createsuccess() const;
  void clear_createsuccess();
  static const int kCreateSuccessFieldNumber = 6;
  const ::headers::CreateAccountSuccess& createsuccess() const;
  ::headers::CreateAccountSuccess* mutable_createsuccess();
  ::headers::CreateAccountSuccess* release_createsuccess();
  void set_allocated_createsuccess(::headers::CreateAccountSuccess* createsuccess);

  // optional .headers.AuthenticateLogin auth = 7;
  bool has_auth() const;
  void clear_auth();
  static const int kAuthFieldNumber = 7;
  const ::headers::AuthenticateLogin& auth() const;
  ::headers::AuthenticateLogin* mutable_auth();
  ::headers::AuthenticateLogin* release_auth();
  void set_allocated_auth(::headers::AuthenticateLogin* auth);

  // optional .headers.AuthenticateFailure authFail = 8;
  bool has_authfail() const;
  void clear_authfail();
  static const int kAuthFailFieldNumber = 8;
  const ::headers::AuthenticateFailure& authfail() const;
  ::headers::AuthenticateFailure* mutable_authfail();
  ::headers::AuthenticateFailure* release_authfail();
  void set_allocated_authfail(::headers::AuthenticateFailure* authfail);

  // optional .headers.AuthenticateSuccess authSuccess = 9;
  bool has_authsuccess() const;
  void clear_authsuccess();
  static const int kAuthSuccessFieldNumber = 9;
  const ::headers::AuthenticateSuccess& authsuccess() const;
  ::headers::AuthenticateSuccess* mutable_authsuccess();
  ::headers::AuthenticateSuccess* release_authsuccess();
  void set_allocated_authsuccess(::headers::AuthenticateSuccess* authsuccess);

  // @@protoc_insertion_point(class_scope:headers.Container)
 private:
  inline void set_has_packetlength();
  inline void clear_has_packetlength();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_create();
  inline void clear_has_create();
  inline void set_has_createfail();
  inline void clear_has_createfail();
  inline void set_has_createsuccess();
  inline void clear_has_createsuccess();
  inline void set_has_auth();
  inline void clear_has_auth();
  inline void set_has_authfail();
  inline void clear_has_authfail();
  inline void set_has_authsuccess();
  inline void clear_has_authsuccess();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::headers::Message* message_;
  ::headers::CreateAccount* create_;
  ::headers::CreateAccountFailure* createfail_;
  ::headers::CreateAccountSuccess* createsuccess_;
  ::headers::AuthenticateLogin* auth_;
  ::headers::AuthenticateFailure* authfail_;
  ::headers::AuthenticateSuccess* authsuccess_;
  ::google::protobuf::int32 packetlength_;
  int id_;
  friend void  protobuf_InitDefaults_Headers_2eproto_impl();
  friend void  protobuf_AddDesc_Headers_2eproto_impl();
  friend void protobuf_AssignDesc_Headers_2eproto();
  friend void protobuf_ShutdownFile_Headers_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Container> Container_default_instance_;

// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// CreateAccount

// required string userName = 1;
inline bool CreateAccount::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateAccount::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateAccount::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateAccount::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_username();
}
inline const ::std::string& CreateAccount::username() const {
  // @@protoc_insertion_point(field_get:headers.CreateAccount.userName)
  return username_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateAccount::set_username(const ::std::string& value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:headers.CreateAccount.userName)
}
inline void CreateAccount::set_username(const char* value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:headers.CreateAccount.userName)
}
inline void CreateAccount::set_username(const char* value, size_t size) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:headers.CreateAccount.userName)
}
inline ::std::string* CreateAccount::mutable_username() {
  set_has_username();
  // @@protoc_insertion_point(field_mutable:headers.CreateAccount.userName)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateAccount::release_username() {
  // @@protoc_insertion_point(field_release:headers.CreateAccount.userName)
  clear_has_username();
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateAccount::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    set_has_username();
  } else {
    clear_has_username();
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:headers.CreateAccount.userName)
}

// required string password = 2;
inline bool CreateAccount::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateAccount::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateAccount::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateAccount::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_password();
}
inline const ::std::string& CreateAccount::password() const {
  // @@protoc_insertion_point(field_get:headers.CreateAccount.password)
  return password_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateAccount::set_password(const ::std::string& value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:headers.CreateAccount.password)
}
inline void CreateAccount::set_password(const char* value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:headers.CreateAccount.password)
}
inline void CreateAccount::set_password(const char* value, size_t size) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:headers.CreateAccount.password)
}
inline ::std::string* CreateAccount::mutable_password() {
  set_has_password();
  // @@protoc_insertion_point(field_mutable:headers.CreateAccount.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateAccount::release_password() {
  // @@protoc_insertion_point(field_release:headers.CreateAccount.password)
  clear_has_password();
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateAccount::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    set_has_password();
  } else {
    clear_has_password();
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:headers.CreateAccount.password)
}

inline const CreateAccount* CreateAccount::internal_default_instance() {
  return &CreateAccount_default_instance_.get();
}
// -------------------------------------------------------------------

// CreateAccountSuccess

// required string userID = 1;
inline bool CreateAccountSuccess::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateAccountSuccess::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateAccountSuccess::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateAccountSuccess::clear_userid() {
  userid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_userid();
}
inline const ::std::string& CreateAccountSuccess::userid() const {
  // @@protoc_insertion_point(field_get:headers.CreateAccountSuccess.userID)
  return userid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateAccountSuccess::set_userid(const ::std::string& value) {
  set_has_userid();
  userid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:headers.CreateAccountSuccess.userID)
}
inline void CreateAccountSuccess::set_userid(const char* value) {
  set_has_userid();
  userid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:headers.CreateAccountSuccess.userID)
}
inline void CreateAccountSuccess::set_userid(const char* value, size_t size) {
  set_has_userid();
  userid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:headers.CreateAccountSuccess.userID)
}
inline ::std::string* CreateAccountSuccess::mutable_userid() {
  set_has_userid();
  // @@protoc_insertion_point(field_mutable:headers.CreateAccountSuccess.userID)
  return userid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateAccountSuccess::release_userid() {
  // @@protoc_insertion_point(field_release:headers.CreateAccountSuccess.userID)
  clear_has_userid();
  return userid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateAccountSuccess::set_allocated_userid(::std::string* userid) {
  if (userid != NULL) {
    set_has_userid();
  } else {
    clear_has_userid();
  }
  userid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), userid);
  // @@protoc_insertion_point(field_set_allocated:headers.CreateAccountSuccess.userID)
}

inline const CreateAccountSuccess* CreateAccountSuccess::internal_default_instance() {
  return &CreateAccountSuccess_default_instance_.get();
}
// -------------------------------------------------------------------

// CreateAccountFailure

// required .headers.CreateAccountFailure.reason errorReason = 1;
inline bool CreateAccountFailure::has_errorreason() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateAccountFailure::set_has_errorreason() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateAccountFailure::clear_has_errorreason() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateAccountFailure::clear_errorreason() {
  errorreason_ = -12312;
  clear_has_errorreason();
}
inline ::headers::CreateAccountFailure_reason CreateAccountFailure::errorreason() const {
  // @@protoc_insertion_point(field_get:headers.CreateAccountFailure.errorReason)
  return static_cast< ::headers::CreateAccountFailure_reason >(errorreason_);
}
inline void CreateAccountFailure::set_errorreason(::headers::CreateAccountFailure_reason value) {
  assert(::headers::CreateAccountFailure_reason_IsValid(value));
  set_has_errorreason();
  errorreason_ = value;
  // @@protoc_insertion_point(field_set:headers.CreateAccountFailure.errorReason)
}

inline const CreateAccountFailure* CreateAccountFailure::internal_default_instance() {
  return &CreateAccountFailure_default_instance_.get();
}
// -------------------------------------------------------------------

// AuthenticateLogin

// required string userName = 1;
inline bool AuthenticateLogin::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthenticateLogin::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthenticateLogin::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthenticateLogin::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_username();
}
inline const ::std::string& AuthenticateLogin::username() const {
  // @@protoc_insertion_point(field_get:headers.AuthenticateLogin.userName)
  return username_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateLogin::set_username(const ::std::string& value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:headers.AuthenticateLogin.userName)
}
inline void AuthenticateLogin::set_username(const char* value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:headers.AuthenticateLogin.userName)
}
inline void AuthenticateLogin::set_username(const char* value, size_t size) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:headers.AuthenticateLogin.userName)
}
inline ::std::string* AuthenticateLogin::mutable_username() {
  set_has_username();
  // @@protoc_insertion_point(field_mutable:headers.AuthenticateLogin.userName)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthenticateLogin::release_username() {
  // @@protoc_insertion_point(field_release:headers.AuthenticateLogin.userName)
  clear_has_username();
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateLogin::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    set_has_username();
  } else {
    clear_has_username();
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:headers.AuthenticateLogin.userName)
}

// required string password = 2;
inline bool AuthenticateLogin::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AuthenticateLogin::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AuthenticateLogin::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AuthenticateLogin::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_password();
}
inline const ::std::string& AuthenticateLogin::password() const {
  // @@protoc_insertion_point(field_get:headers.AuthenticateLogin.password)
  return password_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateLogin::set_password(const ::std::string& value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:headers.AuthenticateLogin.password)
}
inline void AuthenticateLogin::set_password(const char* value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:headers.AuthenticateLogin.password)
}
inline void AuthenticateLogin::set_password(const char* value, size_t size) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:headers.AuthenticateLogin.password)
}
inline ::std::string* AuthenticateLogin::mutable_password() {
  set_has_password();
  // @@protoc_insertion_point(field_mutable:headers.AuthenticateLogin.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthenticateLogin::release_password() {
  // @@protoc_insertion_point(field_release:headers.AuthenticateLogin.password)
  clear_has_password();
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateLogin::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    set_has_password();
  } else {
    clear_has_password();
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:headers.AuthenticateLogin.password)
}

inline const AuthenticateLogin* AuthenticateLogin::internal_default_instance() {
  return &AuthenticateLogin_default_instance_.get();
}
// -------------------------------------------------------------------

// AuthenticateSuccess

// required string userID = 1;
inline bool AuthenticateSuccess::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthenticateSuccess::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthenticateSuccess::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthenticateSuccess::clear_userid() {
  userid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_userid();
}
inline const ::std::string& AuthenticateSuccess::userid() const {
  // @@protoc_insertion_point(field_get:headers.AuthenticateSuccess.userID)
  return userid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateSuccess::set_userid(const ::std::string& value) {
  set_has_userid();
  userid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:headers.AuthenticateSuccess.userID)
}
inline void AuthenticateSuccess::set_userid(const char* value) {
  set_has_userid();
  userid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:headers.AuthenticateSuccess.userID)
}
inline void AuthenticateSuccess::set_userid(const char* value, size_t size) {
  set_has_userid();
  userid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:headers.AuthenticateSuccess.userID)
}
inline ::std::string* AuthenticateSuccess::mutable_userid() {
  set_has_userid();
  // @@protoc_insertion_point(field_mutable:headers.AuthenticateSuccess.userID)
  return userid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthenticateSuccess::release_userid() {
  // @@protoc_insertion_point(field_release:headers.AuthenticateSuccess.userID)
  clear_has_userid();
  return userid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateSuccess::set_allocated_userid(::std::string* userid) {
  if (userid != NULL) {
    set_has_userid();
  } else {
    clear_has_userid();
  }
  userid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), userid);
  // @@protoc_insertion_point(field_set_allocated:headers.AuthenticateSuccess.userID)
}

// required string creationDate = 2;
inline bool AuthenticateSuccess::has_creationdate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AuthenticateSuccess::set_has_creationdate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AuthenticateSuccess::clear_has_creationdate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AuthenticateSuccess::clear_creationdate() {
  creationdate_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_creationdate();
}
inline const ::std::string& AuthenticateSuccess::creationdate() const {
  // @@protoc_insertion_point(field_get:headers.AuthenticateSuccess.creationDate)
  return creationdate_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateSuccess::set_creationdate(const ::std::string& value) {
  set_has_creationdate();
  creationdate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:headers.AuthenticateSuccess.creationDate)
}
inline void AuthenticateSuccess::set_creationdate(const char* value) {
  set_has_creationdate();
  creationdate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:headers.AuthenticateSuccess.creationDate)
}
inline void AuthenticateSuccess::set_creationdate(const char* value, size_t size) {
  set_has_creationdate();
  creationdate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:headers.AuthenticateSuccess.creationDate)
}
inline ::std::string* AuthenticateSuccess::mutable_creationdate() {
  set_has_creationdate();
  // @@protoc_insertion_point(field_mutable:headers.AuthenticateSuccess.creationDate)
  return creationdate_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthenticateSuccess::release_creationdate() {
  // @@protoc_insertion_point(field_release:headers.AuthenticateSuccess.creationDate)
  clear_has_creationdate();
  return creationdate_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateSuccess::set_allocated_creationdate(::std::string* creationdate) {
  if (creationdate != NULL) {
    set_has_creationdate();
  } else {
    clear_has_creationdate();
  }
  creationdate_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), creationdate);
  // @@protoc_insertion_point(field_set_allocated:headers.AuthenticateSuccess.creationDate)
}

inline const AuthenticateSuccess* AuthenticateSuccess::internal_default_instance() {
  return &AuthenticateSuccess_default_instance_.get();
}
// -------------------------------------------------------------------

// AuthenticateFailure

// required .headers.AuthenticateFailure.reason errorReason = 1;
inline bool AuthenticateFailure::has_errorreason() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthenticateFailure::set_has_errorreason() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthenticateFailure::clear_has_errorreason() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthenticateFailure::clear_errorreason() {
  errorreason_ = -14714;
  clear_has_errorreason();
}
inline ::headers::AuthenticateFailure_reason AuthenticateFailure::errorreason() const {
  // @@protoc_insertion_point(field_get:headers.AuthenticateFailure.errorReason)
  return static_cast< ::headers::AuthenticateFailure_reason >(errorreason_);
}
inline void AuthenticateFailure::set_errorreason(::headers::AuthenticateFailure_reason value) {
  assert(::headers::AuthenticateFailure_reason_IsValid(value));
  set_has_errorreason();
  errorreason_ = value;
  // @@protoc_insertion_point(field_set:headers.AuthenticateFailure.errorReason)
}

inline const AuthenticateFailure* AuthenticateFailure::internal_default_instance() {
  return &AuthenticateFailure_default_instance_.get();
}
// -------------------------------------------------------------------

// Message

// required string userName = 1;
inline bool Message::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_username();
}
inline const ::std::string& Message::username() const {
  // @@protoc_insertion_point(field_get:headers.Message.userName)
  return username_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Message::set_username(const ::std::string& value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:headers.Message.userName)
}
inline void Message::set_username(const char* value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:headers.Message.userName)
}
inline void Message::set_username(const char* value, size_t size) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:headers.Message.userName)
}
inline ::std::string* Message::mutable_username() {
  set_has_username();
  // @@protoc_insertion_point(field_mutable:headers.Message.userName)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Message::release_username() {
  // @@protoc_insertion_point(field_release:headers.Message.userName)
  clear_has_username();
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Message::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    set_has_username();
  } else {
    clear_has_username();
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:headers.Message.userName)
}

// required string roomName = 2;
inline bool Message::has_roomname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message::set_has_roomname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message::clear_has_roomname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message::clear_roomname() {
  roomname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_roomname();
}
inline const ::std::string& Message::roomname() const {
  // @@protoc_insertion_point(field_get:headers.Message.roomName)
  return roomname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Message::set_roomname(const ::std::string& value) {
  set_has_roomname();
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:headers.Message.roomName)
}
inline void Message::set_roomname(const char* value) {
  set_has_roomname();
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:headers.Message.roomName)
}
inline void Message::set_roomname(const char* value, size_t size) {
  set_has_roomname();
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:headers.Message.roomName)
}
inline ::std::string* Message::mutable_roomname() {
  set_has_roomname();
  // @@protoc_insertion_point(field_mutable:headers.Message.roomName)
  return roomname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Message::release_roomname() {
  // @@protoc_insertion_point(field_release:headers.Message.roomName)
  clear_has_roomname();
  return roomname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Message::set_allocated_roomname(::std::string* roomname) {
  if (roomname != NULL) {
    set_has_roomname();
  } else {
    clear_has_roomname();
  }
  roomname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), roomname);
  // @@protoc_insertion_point(field_set_allocated:headers.Message.roomName)
}

// required string message = 3;
inline bool Message::has_message() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Message::set_has_message() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Message::clear_has_message() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Message::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& Message::message() const {
  // @@protoc_insertion_point(field_get:headers.Message.message)
  return message_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Message::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:headers.Message.message)
}
inline void Message::set_message(const char* value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:headers.Message.message)
}
inline void Message::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:headers.Message.message)
}
inline ::std::string* Message::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:headers.Message.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Message::release_message() {
  // @@protoc_insertion_point(field_release:headers.Message.message)
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Message::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:headers.Message.message)
}

inline const Message* Message::internal_default_instance() {
  return &Message_default_instance_.get();
}
// -------------------------------------------------------------------

// Container

// required int32 packetLength = 1;
inline bool Container::has_packetlength() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Container::set_has_packetlength() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Container::clear_has_packetlength() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Container::clear_packetlength() {
  packetlength_ = 0;
  clear_has_packetlength();
}
inline ::google::protobuf::int32 Container::packetlength() const {
  // @@protoc_insertion_point(field_get:headers.Container.packetLength)
  return packetlength_;
}
inline void Container::set_packetlength(::google::protobuf::int32 value) {
  set_has_packetlength();
  packetlength_ = value;
  // @@protoc_insertion_point(field_set:headers.Container.packetLength)
}

// required .headers.Container.requestID ID = 2;
inline bool Container::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Container::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Container::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Container::clear_id() {
  id_ = -22022;
  clear_has_id();
}
inline ::headers::Container_requestID Container::id() const {
  // @@protoc_insertion_point(field_get:headers.Container.ID)
  return static_cast< ::headers::Container_requestID >(id_);
}
inline void Container::set_id(::headers::Container_requestID value) {
  assert(::headers::Container_requestID_IsValid(value));
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:headers.Container.ID)
}

// optional .headers.Message message = 3;
inline bool Container::has_message() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Container::set_has_message() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Container::clear_has_message() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Container::clear_message() {
  if (message_ != NULL) message_->::headers::Message::Clear();
  clear_has_message();
}
inline const ::headers::Message& Container::message() const {
  // @@protoc_insertion_point(field_get:headers.Container.message)
  return message_ != NULL ? *message_
                         : *::headers::Message::internal_default_instance();
}
inline ::headers::Message* Container::mutable_message() {
  set_has_message();
  if (message_ == NULL) {
    message_ = new ::headers::Message;
  }
  // @@protoc_insertion_point(field_mutable:headers.Container.message)
  return message_;
}
inline ::headers::Message* Container::release_message() {
  // @@protoc_insertion_point(field_release:headers.Container.message)
  clear_has_message();
  ::headers::Message* temp = message_;
  message_ = NULL;
  return temp;
}
inline void Container::set_allocated_message(::headers::Message* message) {
  delete message_;
  message_ = message;
  if (message) {
    set_has_message();
  } else {
    clear_has_message();
  }
  // @@protoc_insertion_point(field_set_allocated:headers.Container.message)
}

// optional .headers.CreateAccount create = 4;
inline bool Container::has_create() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Container::set_has_create() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Container::clear_has_create() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Container::clear_create() {
  if (create_ != NULL) create_->::headers::CreateAccount::Clear();
  clear_has_create();
}
inline const ::headers::CreateAccount& Container::create() const {
  // @@protoc_insertion_point(field_get:headers.Container.create)
  return create_ != NULL ? *create_
                         : *::headers::CreateAccount::internal_default_instance();
}
inline ::headers::CreateAccount* Container::mutable_create() {
  set_has_create();
  if (create_ == NULL) {
    create_ = new ::headers::CreateAccount;
  }
  // @@protoc_insertion_point(field_mutable:headers.Container.create)
  return create_;
}
inline ::headers::CreateAccount* Container::release_create() {
  // @@protoc_insertion_point(field_release:headers.Container.create)
  clear_has_create();
  ::headers::CreateAccount* temp = create_;
  create_ = NULL;
  return temp;
}
inline void Container::set_allocated_create(::headers::CreateAccount* create) {
  delete create_;
  create_ = create;
  if (create) {
    set_has_create();
  } else {
    clear_has_create();
  }
  // @@protoc_insertion_point(field_set_allocated:headers.Container.create)
}

// optional .headers.CreateAccountFailure createFail = 5;
inline bool Container::has_createfail() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Container::set_has_createfail() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Container::clear_has_createfail() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Container::clear_createfail() {
  if (createfail_ != NULL) createfail_->::headers::CreateAccountFailure::Clear();
  clear_has_createfail();
}
inline const ::headers::CreateAccountFailure& Container::createfail() const {
  // @@protoc_insertion_point(field_get:headers.Container.createFail)
  return createfail_ != NULL ? *createfail_
                         : *::headers::CreateAccountFailure::internal_default_instance();
}
inline ::headers::CreateAccountFailure* Container::mutable_createfail() {
  set_has_createfail();
  if (createfail_ == NULL) {
    createfail_ = new ::headers::CreateAccountFailure;
  }
  // @@protoc_insertion_point(field_mutable:headers.Container.createFail)
  return createfail_;
}
inline ::headers::CreateAccountFailure* Container::release_createfail() {
  // @@protoc_insertion_point(field_release:headers.Container.createFail)
  clear_has_createfail();
  ::headers::CreateAccountFailure* temp = createfail_;
  createfail_ = NULL;
  return temp;
}
inline void Container::set_allocated_createfail(::headers::CreateAccountFailure* createfail) {
  delete createfail_;
  createfail_ = createfail;
  if (createfail) {
    set_has_createfail();
  } else {
    clear_has_createfail();
  }
  // @@protoc_insertion_point(field_set_allocated:headers.Container.createFail)
}

// optional .headers.CreateAccountSuccess createSuccess = 6;
inline bool Container::has_createsuccess() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Container::set_has_createsuccess() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Container::clear_has_createsuccess() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Container::clear_createsuccess() {
  if (createsuccess_ != NULL) createsuccess_->::headers::CreateAccountSuccess::Clear();
  clear_has_createsuccess();
}
inline const ::headers::CreateAccountSuccess& Container::createsuccess() const {
  // @@protoc_insertion_point(field_get:headers.Container.createSuccess)
  return createsuccess_ != NULL ? *createsuccess_
                         : *::headers::CreateAccountSuccess::internal_default_instance();
}
inline ::headers::CreateAccountSuccess* Container::mutable_createsuccess() {
  set_has_createsuccess();
  if (createsuccess_ == NULL) {
    createsuccess_ = new ::headers::CreateAccountSuccess;
  }
  // @@protoc_insertion_point(field_mutable:headers.Container.createSuccess)
  return createsuccess_;
}
inline ::headers::CreateAccountSuccess* Container::release_createsuccess() {
  // @@protoc_insertion_point(field_release:headers.Container.createSuccess)
  clear_has_createsuccess();
  ::headers::CreateAccountSuccess* temp = createsuccess_;
  createsuccess_ = NULL;
  return temp;
}
inline void Container::set_allocated_createsuccess(::headers::CreateAccountSuccess* createsuccess) {
  delete createsuccess_;
  createsuccess_ = createsuccess;
  if (createsuccess) {
    set_has_createsuccess();
  } else {
    clear_has_createsuccess();
  }
  // @@protoc_insertion_point(field_set_allocated:headers.Container.createSuccess)
}

// optional .headers.AuthenticateLogin auth = 7;
inline bool Container::has_auth() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Container::set_has_auth() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Container::clear_has_auth() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Container::clear_auth() {
  if (auth_ != NULL) auth_->::headers::AuthenticateLogin::Clear();
  clear_has_auth();
}
inline const ::headers::AuthenticateLogin& Container::auth() const {
  // @@protoc_insertion_point(field_get:headers.Container.auth)
  return auth_ != NULL ? *auth_
                         : *::headers::AuthenticateLogin::internal_default_instance();
}
inline ::headers::AuthenticateLogin* Container::mutable_auth() {
  set_has_auth();
  if (auth_ == NULL) {
    auth_ = new ::headers::AuthenticateLogin;
  }
  // @@protoc_insertion_point(field_mutable:headers.Container.auth)
  return auth_;
}
inline ::headers::AuthenticateLogin* Container::release_auth() {
  // @@protoc_insertion_point(field_release:headers.Container.auth)
  clear_has_auth();
  ::headers::AuthenticateLogin* temp = auth_;
  auth_ = NULL;
  return temp;
}
inline void Container::set_allocated_auth(::headers::AuthenticateLogin* auth) {
  delete auth_;
  auth_ = auth;
  if (auth) {
    set_has_auth();
  } else {
    clear_has_auth();
  }
  // @@protoc_insertion_point(field_set_allocated:headers.Container.auth)
}

// optional .headers.AuthenticateFailure authFail = 8;
inline bool Container::has_authfail() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Container::set_has_authfail() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Container::clear_has_authfail() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Container::clear_authfail() {
  if (authfail_ != NULL) authfail_->::headers::AuthenticateFailure::Clear();
  clear_has_authfail();
}
inline const ::headers::AuthenticateFailure& Container::authfail() const {
  // @@protoc_insertion_point(field_get:headers.Container.authFail)
  return authfail_ != NULL ? *authfail_
                         : *::headers::AuthenticateFailure::internal_default_instance();
}
inline ::headers::AuthenticateFailure* Container::mutable_authfail() {
  set_has_authfail();
  if (authfail_ == NULL) {
    authfail_ = new ::headers::AuthenticateFailure;
  }
  // @@protoc_insertion_point(field_mutable:headers.Container.authFail)
  return authfail_;
}
inline ::headers::AuthenticateFailure* Container::release_authfail() {
  // @@protoc_insertion_point(field_release:headers.Container.authFail)
  clear_has_authfail();
  ::headers::AuthenticateFailure* temp = authfail_;
  authfail_ = NULL;
  return temp;
}
inline void Container::set_allocated_authfail(::headers::AuthenticateFailure* authfail) {
  delete authfail_;
  authfail_ = authfail;
  if (authfail) {
    set_has_authfail();
  } else {
    clear_has_authfail();
  }
  // @@protoc_insertion_point(field_set_allocated:headers.Container.authFail)
}

// optional .headers.AuthenticateSuccess authSuccess = 9;
inline bool Container::has_authsuccess() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Container::set_has_authsuccess() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Container::clear_has_authsuccess() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Container::clear_authsuccess() {
  if (authsuccess_ != NULL) authsuccess_->::headers::AuthenticateSuccess::Clear();
  clear_has_authsuccess();
}
inline const ::headers::AuthenticateSuccess& Container::authsuccess() const {
  // @@protoc_insertion_point(field_get:headers.Container.authSuccess)
  return authsuccess_ != NULL ? *authsuccess_
                         : *::headers::AuthenticateSuccess::internal_default_instance();
}
inline ::headers::AuthenticateSuccess* Container::mutable_authsuccess() {
  set_has_authsuccess();
  if (authsuccess_ == NULL) {
    authsuccess_ = new ::headers::AuthenticateSuccess;
  }
  // @@protoc_insertion_point(field_mutable:headers.Container.authSuccess)
  return authsuccess_;
}
inline ::headers::AuthenticateSuccess* Container::release_authsuccess() {
  // @@protoc_insertion_point(field_release:headers.Container.authSuccess)
  clear_has_authsuccess();
  ::headers::AuthenticateSuccess* temp = authsuccess_;
  authsuccess_ = NULL;
  return temp;
}
inline void Container::set_allocated_authsuccess(::headers::AuthenticateSuccess* authsuccess) {
  delete authsuccess_;
  authsuccess_ = authsuccess;
  if (authsuccess) {
    set_has_authsuccess();
  } else {
    clear_has_authsuccess();
  }
  // @@protoc_insertion_point(field_set_allocated:headers.Container.authSuccess)
}

inline const Container* Container::internal_default_instance() {
  return &Container_default_instance_.get();
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace headers

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::headers::CreateAccountFailure_reason> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::headers::CreateAccountFailure_reason>() {
  return ::headers::CreateAccountFailure_reason_descriptor();
}
template <> struct is_proto_enum< ::headers::AuthenticateFailure_reason> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::headers::AuthenticateFailure_reason>() {
  return ::headers::AuthenticateFailure_reason_descriptor();
}
template <> struct is_proto_enum< ::headers::Container_requestID> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::headers::Container_requestID>() {
  return ::headers::Container_requestID_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Headers_2eproto__INCLUDED
